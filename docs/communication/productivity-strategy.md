# 일정 단축 피드백

> "완성도 높은 결과물도 중요하지만, 일정 단축이 필요하다"는 피드백을 받은 적이 있습니다.

## 배경
저는 초기 결함을 최소화하는 것을 중요하게 여겨, 배포 후 장애를 줄여 CS 및 QA 팀의 리소스를 절약하는 것이 전체적인 효율성이라 판단했으나,

회사에서는 "일정 단축이 필요하다"는 피드백을 받은 적이 있습니다.

## 원인 분석
작업 소요 시간을 구체적으로 분석해 본 결과, 시간이 지체된 구간은 **구현** 단계가 아니라 **구현 전 사전 검토** 단계였습니다.

* **파편화된 히스토리 파악**
  * 기획서, 디자인 시안, 실제 운영 배포본 간의 내용이 서로 일치하지 않는 경우가 많았습니다.
  * 이에 따라 개발에 착수하기 전, 정확한 스펙과 변경 내역을 파악하고 기준을 잡는 데 많은 시간을 쏟아야 했습니다.

* **기획 및 디자인 엣지 케이스 사전 검토**
  * 기획이나 디자인 단계에서 미처 고려하지 못한 예외 상황을 개발 전에 미리 파악하고 보완을 요청하는 데 시간을 할애했습니다.
  * **디자인:** 데이터가 하나도 없을 때에 대한 디자인 확인
  * **기획:** 기능 구현 시 발생할 수 있는 다양한 오류 케이스별 상세 처리 정책 검토

즉, 단순 코딩 속도가 느린 것이 아니라, **결과물의 완결성을 위해 타 직군의 누락 사항까지 확인하는 역할**을 수행하느라 전체 시간이 길어졌던 것이었습니다.

## 딜레마: R&R의 경계에 대하여

### Q. 개발자가 왜 기획, 디자인, PM이 할 역할까지 챙기느라 시간을 쓰나요?

**A. "운영 서버에서 문제가 생겼을 때, '문서에 없었으니 제 책임이 아닙니다'라고 변명하고 싶지 않았기 때문입니다."**

**1. 책임의 경계에 대한 고민**
선을 긋는 것이 과연 옳은 태도일까요? 우리는 같은 목표를 향해가는 동료이고, 결국 고객이 마주하는 것은 우리 모두가 함께 만든 서비스입니다.

**2. 개선: 균형점 찾기**
> 하지만 이러한 방식이 전체 일정을 지연시킬 수 있다는 피드백을 수용했습니다.

많은 오류 케이스와 미래의 변화까지 대비하려는 욕심을 내려놓고, 현실적인 타협점을 찾아가고 있습니다.

## 개선 경험

### 1. 사전 협의를 통한 권한 위임
개발속도가 중요한 프로젝트 에서는 **사전 협의 하에** 기획/디자인 권한을 위임받아 반복적인 컨펌을 생략했습니다.

* **정석에 기반한 유연함**: 원래 어떻게 구현해야 하는지 알기 때문에, 어느 부분을 **지금 생략하고, 나중에 채울지** 잘 알고있습니다.
* **주도적 빈틈 메우기**: 기획서 / 피그마에 없는 엣지 케이스를 풍부한 경험을 바탕으로 해결했습니다.

예를 들어 '데이터 없음' 화면을 개발하는 데는 1분도 걸리지 않지만, 

이에 대한 정책 부재로 기획/디자인 요청을 보내고 컨펌을 대기하는 데는 수 시간이 소요됩니다.

인원과 시간이 부족한 상황에서는 이러한 절차를 생략하고 직접 해결하여 효율을 높였습니다.

이러한 판단은 사용자 관점에서 고민했던 경험이 뒷받침되었기에 가능했습니다.

### 2. AI 도구를 활용한 시간과 퀄리티 동시 확보
일정이 **"더"** 중요하지만, 완성도 또한 포기하고 싶지 않은 욕심이 있었습니다.

이 두 가지 상충하는 목표를 모두 달성하기 위해 AI 도구를 실험하고 있습니다.

아직은 생산성 향상을 구체적인 수치로 증명하기에는 부족하지만, 정량적인 성과를 측정할 수 있는 단계까지 AI 활용 숙련도를 높여가는 중입니다.

### 3. Best Practice
> **실력**이 높으면 속도와 퀄리티를 모두 챙길 수 있다고 믿습니다.

그래서 Best Practice를 꾸준히 쌓아나가고 있습니다. [깃허브 링크](https://github.com/developer-choi/best-practice)

## 개선 예시
목록 페이지 개발 시, 상황에 따라 권한을 위임받아 아래 항목들을 스스로 처리하기도 했습니다.

1. **데이터 부재 시 정책:** 목록이 존재하지 않을 때의 안내 문구 및 화면 처리
2. **정보 과다 노출 시 정책:** 닉네임 등이 길어질 경우 말줄임표(...) 처리 또는 줄바꿈 처리
3. **필수 정보 누락 시 정책:** 휴대폰 번호 등 일부 정보가 없을 때의 대체 텍스트(예: '-') 처리
4. **페이징 정책:** 데이터 양에 따른 무한 스크롤 또는 페이지네이션 선택
5. **로딩 상태 처리:** 목록을 불러오는 동안의 스켈레톤(Skeleton) UI 또는 로딩 스피너 적용
6. **인터랙션 로딩:** 수정 버튼 클릭 등 동작 수행 중의 모달 및 로딩 디자인
7. **에러 핸들링:** API 오류 발생 시 상태 코드(403, 500 등)별 사용자 안내 정책

모두 성공 케이스를 뒷받침하는 기본적인 요소들이지만, 없으면 사용자가 바로 아쉬움을 느끼게 되는 부분들입니다.